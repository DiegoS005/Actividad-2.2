# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sy5INGJxzYcWiyorl19eEO6itnCBBL4r
"""

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller, acf
from statsmodels.graphics.tsaplots import plot_acf

# Set the date range
start_date = "2019-11-29"
end_date = "2025-04-08"

# Download stock data from Yahoo Finance
tickers = ["CAT", "MSFT", "META"]
print("Fetching data from Yahoo Finance...")
data = yf.download(tickers, start=start_date, end=end_date, progress=False)

# Inspect the raw data
print("Raw DataFrame head:\n", data.head())
print("DataFrame columns:", data.columns)

# Check if data is empty
if data.empty:
    raise ValueError("No data retrieved from Yahoo Finance. Check internet connection or ticker symbols.")

# Determine the price column to use
if isinstance(data.columns, pd.MultiIndex):
    available_columns = [col[0] for col in data.columns]
    print("MultiIndex top-level columns:", available_columns)
    if 'Adj Close' in available_columns:
        price_data = data['Adj Close']
    elif 'Close' in available_columns:
        price_data = data['Close']
        print("Warning: 'Adj Close' not found. Using 'Close' instead.")
    else:
        raise KeyError(f"Neither 'Adj Close' nor 'Close' found. Available columns: {available_columns}")
else:
    if 'Adj Close' in data.columns:
        price_data = data['Adj Close']
    elif 'Close' in data.columns:
        price_data = data['Close']
        print("Warning: 'Adj Close' not found. Using 'Close' instead.")
    else:
        raise KeyError(f"Neither 'Adj Close' nor 'Close' found. Available columns: {data.columns}")

# 1. Random Walk Simulation
def random_walk_simulation(price_series):
    np.random.seed(42)
    # Match the length of the actual series
    steps = len(price_series)
    random_steps = np.random.normal(0, 1, steps)
    walk = np.cumsum(random_steps)
    # Start from the first actual price
    simulated_series = price_series.iloc[0] + walk
    return simulated_series

# Simulate and plot random walk for each stock individually
for ticker in tickers:
    # Simulate the random walk over the same period as actual data
    simulated_series = random_walk_simulation(price_data[ticker])

    # Use the same dates for both actual and simulated series
    actual_dates = price_data.index

    # Create a separate figure for each stock
    plt.figure(figsize=(10, 5))
    plt.plot(actual_dates, price_data[ticker], label=f"{ticker} Actual", color='blue')
    plt.plot(actual_dates, simulated_series, label=f"{ticker} Simulated", linestyle="--", color='orange')
    plt.title(f"Random Walk Simulation vs Actual for {ticker} (Nov 2019 - Apr 2025)")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.legend()
    plt.grid(True)
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()

# 2. Unit Root Test (Augmented Dickey-Fuller Test)
def unit_root_test(series, ticker):
    result = adfuller(series.dropna())
    print(f"\nUnit Root Test (ADF) for {ticker}:")
    print(f"ADF Statistic: {result[0]:.4f}")
    print(f"p-value: {result[1]:.4f}")
    print("Critical Values:", {k: round(v, 4) for k, v in result[4].items()})
    if result[1] < 0.05:
        print(f"{ticker} is likely stationary (reject null hypothesis).")
    else:
        print(f"{ticker} is likely non-stationary (fail to reject null hypothesis).")

for ticker in tickers:
    unit_root_test(price_data[ticker], ticker)

# 3. Correlogram
def plot_correlogram(series, ticker):
    plt.figure(figsize=(10, 5))
    plot_acf(series.dropna(), lags=40, title=f"Correlogram for {ticker}")
    plt.show()

for ticker in tickers:
    plot_correlogram(price_data[ticker], ticker)

# Calculate Weighted Tail Mean (WTM) - Assuming lower 5% tail
def weighted_tail_mean(series, tail_percent=0.05):
    sorted_series = series.dropna().sort_values()
    tail_size = int(len(sorted_series) * tail_percent)
    if tail_size == 0:
        return np.nan
    tail = sorted_series[:tail_size]
    weights = np.linspace(1, 0, len(tail))
    wtm = np.average(tail, weights=weights)
    return wtm

# Compute and display WTM for each stock
for ticker in tickers:
    wtm = weighted_tail_mean(price_data[ticker])
    print(f"\nWeighted Tail Mean (WTM) for {ticker}: {wtm:.2f}")

def check_stationarity(price_series, stock_name):
    adf_result = adfuller(price_series.dropna())
    print(f"\nStationarity Test for {stock_name}:")
    print(f"Statistic: {adf_result[0]:.4f}")
    print(f"p-value: {adf_result[1]:.4f}")
    print("Thresholds:")
    for level, value in adf_result[4].items():
        print(f"   {level}: {value:.4f}")
    conclusion = "Stationary (rejects unit root)" if adf_result[1] < 0.05 else "Non-stationary (unit root present)"
    print(f"Result: {conclusion}")

# Apply ADF test to actual prices
for symbol in stock_symbols:
    check_stationarity(price_data[symbol], symbol)